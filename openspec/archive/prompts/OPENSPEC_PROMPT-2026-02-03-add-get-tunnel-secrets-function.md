# OpenSpec Prompt: Add get_tunnel_secrets() Dagger Function

## Context

After deploying Cloudflare Tunnels via [`deploy_cloudflare()`](../../src/main/main.py:422-571), users need to retrieve the tunnel tokens to configure [`cloudflared`](../../examples/homelab-media-stack/README.md:325) on their devices. Currently, users must manually run `terraform output -json tunnel_tokens` to get these secrets.

Tunnel tokens are generated by Terraform during [`terraform apply`](../../terraform/modules/cloudflare-tunnel/main.tf:558-561) and stored as sensitive outputs in [`outputs.tf`](../../terraform/modules/cloudflare-tunnel/outputs.tf:11-22). These tokens contain the credentials needed for the cloudflared daemon to authenticate with Cloudflare's edge network.

The current workflow requires users to:
1. Deploy via Dagger: `dagger call deploy-cloudflare ...`
2. Separately query Terraform: `terraform output -json cloudflare_tunnel_tokens`
3. Manually extract tokens for each device MAC address

This creates friction in the user experience and requires users to understand both Dagger and Terraform command-line interfaces.

## Goal

Create a new Dagger function [`get_tunnel_secrets()`](../../src/main/main.py:28) that retrieves Cloudflare tunnel credentials from Terraform state on-demand, providing users a single interface for both deployment and credential retrieval.

## Scope

### In Scope

- New `get_tunnel_secrets()` function in [`UnifiCloudflareGlue`](../../src/main/main.py:25) class
- Extract `tunnel_tokens` output from Terraform state
- Extract `credentials_json` output from Terraform state
- Format output for human readability (default) or JSON (for automation)
- Support both ephemeral and persistent state directories
- Comprehensive parameter documentation with examples
- Error handling for missing state files
- Unit tests for the new function

### Out of Scope

- Modifying existing deployment functions (covered in prompt 02)
- Creating new secrets or tunnels (deployment functions handle this)
- Direct Cloudflare API calls (use existing Terraform state)
- State file encryption or additional security measures
- CLI output colors or fancy formatting

## Desired Behavior

### Function Signature

```python
@function
async def get_tunnel_secrets(
    self,
    source: Annotated[dagger.Directory, Doc("Source directory containing terraform configs")],
    cloudflare_token: Annotated[Secret, Doc("Cloudflare API Token for provider auth")],
    cloudflare_account_id: Annotated[str, Doc("Cloudflare Account ID")],
    zone_name: Annotated[str, Doc("DNS zone name (e.g., example.com)")],
    terraform_version: Annotated[str, Doc("Terraform version to use (e.g., '1.10.0' or 'latest')")] = "latest",
    backend_type: Annotated[str, Doc("Terraform backend type (local, s3, azurerm, gcs, remote, etc.)")] = "local",
    backend_config_file: Annotated[Optional[dagger.File], Doc("Backend configuration HCL file (required for remote backends)")] = None,
    state_dir: Annotated[Optional[dagger.Directory], Doc("Directory containing Terraform state (for persistent local state)")] = None,
    output_format: Annotated[str, Doc("Output format: 'human' (default) or 'json'")] = "human",
) -> str:
    """
    Retrieve Cloudflare tunnel tokens and credentials from Terraform state.
    
    Must be run after deploy_cloudflare() has successfully created tunnels.
    Extracts sensitive tunnel credentials from Terraform outputs for configuring
    cloudflared on your devices.
    
    Args:
        source: Directory containing terraform/modules/cloudflare-tunnel
        cloudflare_token: Cloudflare API Token (same as used for deployment)
        cloudflare_account_id: Cloudflare Account ID (same as used for deployment)
        zone_name: DNS zone name (same as used for deployment)
        terraform_version: Terraform version matching deployment (default: "latest")
        backend_type: Backend type matching deployment (default: "local")
        backend_config_file: Backend config if using remote backend
        state_dir: Persistent state directory if used during deployment
        output_format: 'human' for readable output, 'json' for machine parsing
    
    Returns:
        Formatted tunnel credentials string
    
    Example (local state):
        dagger call get-tunnel-secrets \\
            --source=. \\
            --cloudflare-token=env:CF_TOKEN \\
            --cloudflare-account-id=xxx \\
            --zone-name=example.com
    
    Example (persistent local state):
        dagger call get-tunnel-secrets \\
            --source=. \\
            --cloudflare-token=env:CF_TOKEN \\
            --cloudflare-account-id=xxx \\
            --zone-name=example.com \\
            --state-dir=./terraform-state
    
    Example (remote backend):
        dagger call get-tunnel-secrets \\
            --source=. \\
            --cloudflare-token=env:CF_TOKEN \\
            --cloudflare-account-id=xxx \\
            --zone-name=example.com \\
            --backend-type=s3 \\
            --backend-config-file=./s3-backend.hcl
    
    Example (JSON output for automation):
        dagger call get-tunnel-secrets \\
            --source=. \\
            --cloudflare-token=env:CF_TOKEN \\
            --cloudflare-account-id=xxx \\
            --zone-name=example.com \\
            --output-format=json
    """
```

### Implementation Pattern

Follow the same pattern as [`deploy_cloudflare()`](../../src/main/main.py:422-571):

1. Create Terraform container with same version
2. Mount source and terraform module
3. Handle backend configuration (local vs remote)
4. Mount state directory if provided
5. Run `terraform init` (backend must match deployment)
6. Run `terraform output -json tunnel_tokens`
7. Run `terraform output -json credentials_json`
8. Parse and format output based on `output_format` parameter

### Output Formats

#### Human Format (Default)

```
Cloudflare Tunnel Credentials
==============================

Tunnel Tokens (for cloudflared service installation):

MAC: aa:bb:cc:dd:ee:ff
  Tunnel Name: media-server
  Token: eyJhIjoiN2Q3...

Use with: sudo cloudflared service install <token>

---

Credentials JSON (for manual cloudflared configuration):

MAC: aa:bb:cc:dd:ee:ff
  Tunnel Name: media-server
  Tunnel ID: 12345678-1234-1234-1234-123456789abc
  Account ID: a1b2c3d4e5f6789012345678901234ab
  Secret: base64-encoded-secret-here

Use with: Save to /etc/cloudflared/credentials.json

---

Total tunnels: 1
```

#### JSON Format (For Automation)

```json
{
  "tunnel_tokens": {
    "aa:bb:cc:dd:ee:ff": "eyJhIjoiN2Q3..."
  },
  "credentials_json": {
    "aa:bb:cc:dd:ee:ff": "{\"AccountTag\":\"xxx\",\"TunnelID\":\"yyy\",\"TunnelName\":\"media-server\",\"TunnelSecret\":\"zzz\"}"
  },
  "count": 1
}
```

### Error Handling

Return clear error messages for common failure scenarios:

```python
# No state exists
return "✗ Failed: No Terraform state found. Have you run deploy-cloudflare yet?"

# Backend mismatch
return "✗ Failed: Terraform init failed. Ensure backend-type matches your deployment."

# No tunnels in output
return "✗ Failed: No tunnels found in Terraform outputs. State may be corrupted."

# State directory provided but doesn't exist
return "✗ Failed: State directory not found. Check --state-dir path."
```

## Constraints & Assumptions

### Constraints

1. **State dependency**: Function only works after successful `deploy_cloudflare()` execution
2. **Backend alignment**: Backend configuration must match the deployment (local vs remote)
3. **Terraform version compatibility**: Should use same Terraform version as deployment
4. **Read-only operations**: Function never modifies state or infrastructure
5. **Secret handling**: Must use `with_secret_variable()` for Cloudflare token
6. **No state file parsing**: Use `terraform output`, don't parse state JSON directly

### Assumptions

1. User has already deployed tunnels via `deploy_cloudflare()`
2. Terraform state exists and is accessible
3. State contains `tunnel_tokens` and `credentials_json` outputs
4. User provides same backend configuration used during deployment
5. User has necessary permissions to access backend (local dir or remote storage)

## Acceptance Criteria

### Functional Requirements

- [ ] New `get_tunnel_secrets()` function added to [`src/main/main.py`](../../src/main/main.py:28)
- [ ] Function extracts both `tunnel_tokens` and `credentials_json` outputs
- [ ] Supports `human` and `json` output formats
- [ ] Works with local (ephemeral) state
- [ ] Works with persistent local state (`--state-dir`)
- [ ] Works with remote backends (`--backend-type`, `--backend-config-file`)
- [ ] Validates backend configuration (reuses [`_validate_backend_config()`](../../src/main/main.py:142-178))
- [ ] Validates state storage config (reuses [`_validate_state_storage_config()`](../../src/main/main.py:180-220))
- [ ] Generates backend block (reuses [`_generate_backend_block()`](../../src/main/main.py:222-235))

### Error Handling

- [ ] Returns clear error if state file not found
- [ ] Returns clear error if outputs missing from state
- [ ] Returns clear error if backend configuration invalid
- [ ] Returns clear error if `terraform init` fails
- [ ] Returns clear error if `terraform output` fails

### Documentation

- [ ] Function docstring follows existing pattern (Args, Returns, Examples)
- [ ] At least 3 usage examples showing different backends
- [ ] Parameter documentation using `Annotated[type, Doc("description")]`
- [ ] Example shows JSON output format
- [ ] Example shows state-dir usage

### Testing

- [ ] Unit test: function extracts tokens from mocked Terraform output
- [ ] Unit test: function handles missing state gracefully
- [ ] Unit test: human format output is readable
- [ ] Unit test: JSON format output is valid JSON
- [ ] Integration test: function works after `deploy_cloudflare()` (in existing `test_integration`)

### Code Quality

- [ ] Function follows existing code patterns in [`src/main/main.py`](../../src/main/main.py)
- [ ] Reuses helper methods (`_validate_backend_config`, etc.)
- [ ] Uses `@function` decorator for Dagger exposure
- [ ] Returns `str` (consistent with other public functions)
- [ ] Handles secrets via `with_secret_variable()`
- [ ] No hardcoded paths or values

## Implementation Notes

### Reference Implementation Pattern

Use [`plan()`](../../src/main/main.py:744-1126) as reference for:
- Container setup and module mounting (lines 889-909)
- State directory handling (lines 928-933)
- Extracting files from executed containers (lines 956-963)

Use [`deploy_cloudflare()`](../../src/main/main.py:422-571) as reference for:
- Backend configuration (lines 503-516)
- Environment variable setup (lines 518-524)
- Working directory logic (lines 527-537)

### File Locations

- **Target file**: `src/main/main.py`
- **Test file**: `tests/unit/test_get_tunnel_secrets.py` (new)
- **Reference files**: 
  - `terraform/modules/cloudflare-tunnel/outputs.tf` (output definitions)
  - `examples/homelab-media-stack/README.md` (usage documentation update target)

### Dependencies

- This prompt has no dependencies on other changes
- Prompt 02 depends on this prompt (for command examples)

## Reference

- **Target file**: [`src/main/main.py`](../../src/main/main.py) (new function after line 572)
- **Terraform outputs**: [`terraform/modules/cloudflare-tunnel/outputs.tf`](../../terraform/modules/cloudflare-tunnel/outputs.tf:11-22)
- **Pattern references**: 
  - [`plan()`](../../src/main/main.py:744-1126) for state file extraction
  - [`deploy_cloudflare()`](../../src/main/main.py:422-571) for setup pattern
- **Dagger docs**: https://docs.dagger.io/api/secrets
