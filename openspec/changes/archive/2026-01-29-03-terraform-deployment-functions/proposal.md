# Proposal: Terraform Deployment Functions

## Change ID
`03-terraform-deployment-functions`

## Summary
Implement Dagger functions to deploy infrastructure via Terraform, with proper secret handling for UniFi and Cloudflare credentials. These functions containerize the Terraform CLI and orchestrate deployments in the correct order (UniFi first, then Cloudflare) while ensuring sensitive credentials are handled securely using Dagger's `Secret` type.

## Motivation

With the KCL generation functions complete (see archived `kcl-generation-functions`), users can now generate JSON configurations for both UniFi and Cloudflare. The next step is to provide deployment capabilities that:

1. **Eliminate Local Terraform**: Users don't need Terraform installed locally
2. **Secure Credential Handling**: All API keys and tokens use Dagger's `Secret` type, never exposed in logs
3. **Deployment Orchestration**: Automatically deploys UniFi first (creates local DNS), then Cloudflare (tunnels point to resolvable hostnames)
4. **CI/CD Ready**: Works identically in CI pipelines and locally
5. **Emergency Cleanup**: Provides destroy function for resource teardown

## Scope

### In Scope
- Add `deploy_unifi` Dagger function for UniFi DNS deployment
- Add `deploy_cloudflare` Dagger function for Cloudflare Tunnel deployment
- Add `deploy` Dagger function that orchestrates both (UniFi first, then Cloudflare)
- Add `destroy` Dagger function for emergency teardown
- Containerize Terraform using official HashiCorp images
- Secure credential handling via Dagger Secrets
- Support for both API key and username/password authentication for UniFi

### Out of Scope
- Integration testing with ephemeral resources (prompt 04)
- Modifying Terraform modules themselves
- State backend configuration (use local or existing backend via standard Terraform means)
- Multi-environment state management

## Proposed Solution

### Function Architecture

#### `deploy_unifi`
Deploys UniFi DNS configuration using the Terraform UniFi DNS module.

**Authentication Options** (mutually exclusive):
1. **API Key (Preferred)**: `unifi_api_key` Secret
2. **Username/Password**: `unifi_username` and `unifi_password` Secrets

**Parameters**:
- `source`: Directory containing `unifi.json` generated by KCL
- `unifi_url`: UniFi Controller URL
- `api_url`: UniFi API URL (optional, defaults to `unifi_url`)
- `unifi_api_key`: API key for authentication (Secret, optional)
- `unifi_username`: Username for authentication (Secret, optional)
- `unifi_password`: Password for authentication (Secret, optional)

**Returns**: `str` - deployment status message

#### `deploy_cloudflare`
Deploys Cloudflare Tunnel configuration using the Terraform Cloudflare Tunnel module.

**Parameters**:
- `source`: Directory containing `cloudflare.json` generated by KCL
- `cloudflare_token`: Cloudflare API Token (Secret)
- `cloudflare_account_id`: Cloudflare Account ID
- `zone_name`: DNS zone name

**Returns**: `str` - deployment status message

#### `deploy` (Orchestration)
Combines KCL generation and deployment in the correct order.

**Execution Order**:
1. Generate UniFi config from KCL
2. Generate Cloudflare config from KCL
3. Deploy UniFi (creates local DNS)
4. Deploy Cloudflare (tunnels point to now-resolvable hostnames)

**Parameters**: All parameters from `deploy_unifi` and `deploy_cloudflare` combined, plus:
- `kcl_source`: Source directory containing KCL configs

**Returns**: `str` - combined deployment status

#### `destroy`
Destroys resources in the reverse order of deployment.

**Execution Order**:
1. Destroy Cloudflare resources first (avoid DNS loops)
2. Destroy UniFi resources second

**Parameters**: Same as `deploy`

**Returns**: `str` - destruction status message

### Container Architecture

**Base Image**: `hashicorp/terraform:latest` (official Terraform image)

**Container Setup**:
1. Pull official Terraform image
2. Mount source directory containing JSON configs
3. Mount Terraform module from repository
4. Set working directory to module path
5. Configure Terraform variables via environment variables (`TF_VAR_*`)
6. Execute `terraform apply` or `terraform destroy`

**Security**:
- Secrets passed via `TF_VAR_*` environment variables (never in command line)
- Secret values never logged
- Terraform state files handled securely

### Credential Handling

All sensitive inputs use `dagger.Secret` type:

**UniFi** (mutually exclusive):
- Option 1: `unifi_api_key` (Secret) - preferred
- Option 2: `unifi_username` (Secret) + `unifi_password` (Secret)

**Cloudflare**:
- `cloudflare_token` (Secret) - required

Validation ensures either API key OR username/password is provided for UniFi, not both.

### Error Handling

All functions handle:
- Missing JSON configuration files
- Invalid Terraform configuration
- Authentication failures
- Provider API errors
- State lock issues

Error messages include:
- Clear indication of what failed
- Terraform output for debugging
- Suggested fixes

## Dependencies

- **Depends On**: `kcl-generation-functions` (must be archived/completed)
- **Uses**: Terraform modules at `terraform/modules/unifi-dns/` and `terraform/modules/cloudflare-tunnel/`
- **Blocks**: `04-integration-test-function` (deployment needed for integration testing)

## Success Criteria

- [ ] `deploy_unifi` function exists with API key and username/password auth options
- [ ] `deploy_cloudflare` function exists with proper secret handling
- [ ] `deploy` orchestration function runs KCL gen → UniFi → Cloudflare in order
- [ ] `destroy` function tears down resources in reverse order (Cloudflare first)
- [ ] All functions use `dagger.Secret` for sensitive data
- [ ] All functions return clear status messages (✓ Success or ✗ Failed)
- [ ] Example usage works:
  ```bash
  # Deploy UniFi with API key
  dagger call deploy-unifi \
    --source=. \
    --unifi-api-key=env:UNIFI_API_KEY \
    --unifi-url=https://unifi.local:8443

  # Deploy Cloudflare
  dagger call deploy-cloudflare \
    --source=. \
    --cloudflare-token=env:CF_TOKEN \
    --cloudflare-account-id=xxx \
    --zone-name=example.com

  # Full deployment
  dagger call deploy \
    --kcl-source=./kcl \
    --unifi-api-key=env:UNIFI_API_KEY \
    --unifi-url=https://unifi.local:8443 \
    --cloudflare-token=env:CF_TOKEN \
    --cloudflare-account-id=xxx \
    --zone-name=example.com
  ```

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Terraform state corruption | High | Document backup procedures; use remote state for production |
| Secret exposure in logs | Critical | Use Dagger Secret type; secrets never appear in output |
| Provider API rate limits | Medium | Implement retries; document rate limit handling |
| Authentication failures | Medium | Clear error messages; validate auth before apply |
| Wrong deployment order | High | Hardcoded order: UniFi first, Cloudflare second |

## Related Documents

- Prompt: [`03-terraform-deployment-functions.md`](../../prompts/03-terraform-deployment-functions.md)
- KCL Generation Functions: (archived `kcl-generation-functions`)
- Terraform UniFi Module: [`terraform/modules/unifi-dns/`](../../terraform/modules/unifi-dns/)
- Terraform Cloudflare Module: [`terraform/modules/cloudflare-tunnel/`](../../terraform/modules/cloudflare-tunnel/)
- Dagger Module: [`src/main/main.py`](../../src/main/main.py)
- OpenSpec Project: [`openspec/project.md`](../../project.md)
